angular.module("ngDraggable", []).service("ngDraggable", [function () {
    var t = this;
    t.inputEvent = function (t) {
        return angular.isDefined(t.touches) ? t.touches[0] : angular.isDefined(t.originalEvent) && angular.isDefined(t.originalEvent.touches) ? t.originalEvent.touches[0] : t
    }, t.touchTimeout = 100
}]).directive("ngDrag", ["$rootScope", "$parse", "$document", "$window", "ngDraggable", function (t, n, e, a, o) {
    return {
        restrict: "A", link: function (r, i, c) {
            r.value = c.ngDrag;
            var l, u, s, g, f, d, m, v, p = !1, $ = ("ontouchstart"in window || window.DocumentTouch && document instanceof DocumentTouch, "touchstart mousedown"), D = "touchmove mousemove", h = "touchend mouseup", b = r.$id, w = null, y = null, x = !1, S = null, E = n(c.ngDragStart) || null, C = n(c.ngDragStop) || null, T = n(c.ngDragSuccess) || null, A = !angular.isDefined(c.allowTransform) || r.$eval(c.allowTransform), k = n(c.ngDragData), X = angular.noop, Y = function () {
                if (i.attr("draggable", "false"), i[0].querySelectorAll)var t = angular.element(i[0].querySelectorAll("[ng-drag-handle]")); else var t = i.find("[ng-drag-handle]");
                t.length && (v = t), O(!0)
            }, O = function (t) {
                t && (r.$on("$destroy", z), r.$watch(c.ngDrag, q), r.$watch(c.ngCenterAnchor, H), v ? v.on($, M) : i.on($, M), "img" == i[0].nodeName.toLowerCase() && i.on("mousedown", function () {
                    return !1
                }))
            }, z = function (t) {
                O(!1)
            }, q = function (t, n) {
                x = t
            }, H = function (t, n) {
                angular.isDefined(t) && (p = t || "true")
            }, L = function (t) {
                return angular.isDefined(angular.element(t.target).attr("ng-cancel-drag"))
            }, M = function (t) {
                if (x && !L(t) && ("mousedown" != t.type || 0 == t.button)) {
                    var n = "touchstart" === t.type;
                    n ? (R(), S = setTimeout(function () {
                        R(), _(t)
                    }, o.touchTimeout), e.on(D, R), e.on(h, R)) : _(t)
                }
            }, R = function () {
                clearTimeout(S), e.off(D, R), e.off(h, R)
            }, _ = function (n) {
                x && (n.preventDefault(), l = i[0].getBoundingClientRect(), y = A ? l : {
                    left: document.body.scrollLeft,
                    top: document.body.scrollTop
                }, i.centerX = i[0].offsetWidth / 2, i.centerY = i[0].offsetHeight / 2, u = o.inputEvent(n).pageX, s = o.inputEvent(n).pageY, d = u - l.left, m = s - l.top, p ? (g = u - i.centerX - a.pageXOffset, f = s - i.centerY - a.pageYOffset) : (g = u - d - a.pageXOffset, f = s - m - a.pageYOffset), e.on(D, B), e.on(h, F), X = t.$on("draggable:_triggerHandlerMove", function (t, n) {
                    B(n)
                }))
            }, B = function (n) {
                x && (n.preventDefault(), i.hasClass("dragging") || (w = k(r), i.addClass("dragging"), t.$broadcast("draggable:start", {
                    x: u,
                    y: s,
                    tx: g,
                    ty: f,
                    event: n,
                    element: i,
                    data: w
                }), E && r.$apply(function () {
                    E(r, {$data: w, $event: n})
                })), u = o.inputEvent(n).pageX, s = o.inputEvent(n).pageY, p ? (g = u - i.centerX - y.left, f = s - i.centerY - y.top) : (g = u - d - y.left, f = s - m - y.top), V(g, f), t.$broadcast("draggable:move", {
                    x: u,
                    y: s,
                    tx: g,
                    ty: f,
                    event: n,
                    element: i,
                    data: w,
                    uid: b,
                    dragOffset: y
                }))
            }, F = function (n) {
                x && (n.preventDefault(), t.$broadcast("draggable:end", {
                    x: u,
                    y: s,
                    tx: g,
                    ty: f,
                    event: n,
                    element: i,
                    data: w,
                    callback: P,
                    uid: b
                }), i.removeClass("dragging"), i.parent().find(".drag-enter").removeClass("drag-enter"), W(), e.off(D, B), e.off(h, F), C && r.$apply(function () {
                    C(r, {$data: w, $event: n})
                }), X())
            }, P = function (t) {
                T && r.$apply(function () {
                    T(r, {$data: w, $event: t})
                })
            }, W = function () {
                A ? i.css({
                    transform: "",
                    "z-index": "",
                    "-webkit-transform": "",
                    "-ms-transform": ""
                }) : i.css({position: "", top: "", left: ""})
            }, V = function (t, n) {
                A ? i.css({
                    transform: "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, " + t + ", " + n + ", 0, 1)",
                    "z-index": 99999,
                    "-webkit-transform": "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, " + t + ", " + n + ", 0, 1)",
                    "-ms-transform": "matrix(1, 0, 0, 1, " + t + ", " + n + ")"
                }) : i.css({left: t + "px", top: n + "px", position: "fixed"})
            };
            Y()
        }
    }
}]).directive("ngDrop", ["$parse", "$timeout", "$window", "$document", "ngDraggable", function (t, n, e, a, o) {
    return {
        restrict: "A", link: function (e, o, r) {
            e.value = r.ngDrop, e.isTouching = !1;
            var i = null, c = e.$id, l = !1, u = t(r.ngDropSuccess), s = t(r.ngDragStart), g = t(r.ngDragStop), f = t(r.ngDragMove), d = function () {
                m(!0)
            }, m = function (t) {
                t && (e.$watch(r.ngDrop, p), e.$on("$destroy", v), e.$on("draggable:start", $), e.$on("draggable:move", D), e.$on("draggable:end", h))
            }, v = function (t) {
                m(!1)
            }, p = function (t, n) {
                l = t
            }, $ = function (t, a) {
                l && (b(a.x, a.y, a.element), r.ngDragStart && n(function () {
                    s(e, {$data: a.data, $event: a})
                }))
            }, D = function (t, a) {
                l && (b(a.x, a.y, a.element), r.ngDragMove && n(function () {
                    f(e, {$data: a.data, $event: a})
                }))
            }, h = function (t, a) {
                return l && c !== a.uid ? (b(a.x, a.y, a.element) && (a.callback && a.callback(a), r.ngDropSuccess && n(function () {
                    u(e, {$data: a.data, $event: a, $target: e.$eval(e.value)})
                })), r.ngDragStop && n(function () {
                    g(e, {$data: a.data, $event: a})
                }), void w(!1, a.element)) : void w(!1, a.element)
            }, b = function (t, n, a) {
                var r = y(t, n);
                return e.isTouching = r, r && (i = o), w(r, a), r
            }, w = function (t, n) {
                t ? (o.addClass("drag-enter"), n.addClass("drag-over")) : i == o && (i = null, o.removeClass("drag-enter"), n.removeClass("drag-over"))
            }, y = function (t, n) {
                var e = o[0].getBoundingClientRect();
                return t -= a[0].body.scrollLeft + a[0].documentElement.scrollLeft, n -= a[0].body.scrollTop + a[0].documentElement.scrollTop, t >= e.left && t <= e.right && n <= e.bottom && n >= e.top
            };
            d()
        }
    }
}]).directive("ngDragClone", ["$parse", "$timeout", "ngDraggable", function (t, n, e) {
    return {
        restrict: "A", link: function (t, n, e) {
            var a, o = !0;
            t.clonedData = {};
            var r = function () {
                a = n.find("img"), n.attr("draggable", "false"), a.attr("draggable", "false"), g(), i(!0)
            }, i = function (n) {
                n && (t.$on("draggable:start", l), t.$on("draggable:move", u), t.$on("draggable:end", s), c())
            }, c = function () {
                a.off("mousedown touchstart touchmove touchend touchcancel", d), a.on("mousedown touchstart touchmove touchend touchcancel", d)
            }, l = function (e, a, r) {
                o = !0, angular.isDefined(a.data.allowClone) && (o = a.data.allowClone), o && (t.$apply(function () {
                    t.clonedData = a.data
                }), n.css("width", a.element[0].offsetWidth), n.css("height", a.element[0].offsetHeight), f(a.tx, a.ty))
            }, u = function (t, n) {
                o && (_tx = n.tx + n.dragOffset.left, _ty = n.ty + n.dragOffset.top, f(_tx, _ty))
            }, s = function (t, n) {
                o && g()
            }, g = function () {
                n.css({left: 0, top: 0, position: "fixed", "z-index": -1, visibility: "hidden"})
            }, f = function (t, e) {
                n.css({
                    transform: "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, " + t + ", " + e + ", 0, 1)",
                    "z-index": 99999,
                    visibility: "visible",
                    "-webkit-transform": "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, " + t + ", " + e + ", 0, 1)",
                    "-ms-transform": "matrix(1, 0, 0, 1, " + t + ", " + e + ")"
                })
            }, d = function (t) {
                var n = t;
                return n.preventDefault && n.preventDefault(), n.stopPropagation && n.stopPropagation(), n.cancelBubble = !0, n.returnValue = !1, !1
            };
            r()
        }
    }
}]).directive("ngPreventDrag", ["$parse", "$timeout", function (t, n) {
    return {
        restrict: "A", link: function (t, n, e) {
            var a = function () {
                n.attr("draggable", "false"), o(!0)
            }, o = function (t) {
                t && n.on("mousedown touchstart touchmove touchend touchcancel", r)
            }, r = function (t) {
                var n = t.originalEvent;
                return n.preventDefault && n.preventDefault(), n.stopPropagation && n.stopPropagation(), n.cancelBubble = !0, n.returnValue = !1, !1
            };
            a()
        }
    }
}]).directive("ngCancelDrag", [function () {
    return {
        restrict: "A", link: function (t, n, e) {
            n.find("*").attr("ng-cancel-drag", "ng-cancel-drag")
        }
    }
}]).directive("ngDragScroll", ["$window", "$interval", "$timeout", "$document", "$rootScope", function (t, n, e, a, o) {
    return {
        restrict: "A", link: function (n, e, r) {
            var i = null, c = {
                verticalScroll: r.verticalScroll || !0,
                horizontalScroll: r.horizontalScroll || !0,
                activationDistance: r.activationDistance || 75,
                scrollDistance: r.scrollDistance || 15
            }, l = function () {
                return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t, n) {
                        window.setTimeout(t, 1e3 / 60)
                    }
            }(), u = !1, s = function () {
                function n(t) {
                    var e = Array.prototype.slice.call(arguments);
                    u && l(function () {
                        o.$apply(function () {
                            t.apply(null, e), n(t)
                        })
                    })
                }

                u = !0, n(function () {
                    if (i) {
                        var n = Math.max(document.documentElement.clientWidth, window.innerWidth || 0), r = Math.max(document.documentElement.clientHeight, window.innerHeight || 0), l = 0, u = 0;
                        if (c.horizontalScroll && (i.clientX < c.activationDistance ? l = -c.scrollDistance : i.clientX > n - c.activationDistance && (l = c.scrollDistance)), c.verticalScroll && (i.clientY < c.activationDistance ? u = -c.scrollDistance : i.clientY > r - c.activationDistance && (u = c.scrollDistance)), 0 !== l || 0 !== u) {
                            var s = t.pageXOffset || a[0].documentElement.scrollLeft, g = t.pageYOffset || a[0].documentElement.scrollTop, f = e.css("transform");
                            e.css("transform", "initial"), t.scrollBy(l, u);
                            var d = (t.pageXOffset || a[0].documentElement.scrollLeft) - s, m = (t.pageYOffset || a[0].documentElement.scrollTop) - g;
                            e.css("transform", f), i.pageX += d, i.pageY += m, o.$emit("draggable:_triggerHandlerMove", i)
                        }
                    }
                })
            }, g = function () {
                u = !1
            };
            n.$on("draggable:start", function (t, n) {
                n.element[0] === e[0] && (u || s())
            }), n.$on("draggable:end", function (t, n) {
                n.element[0] === e[0] && u && g()
            }), n.$on("draggable:move", function (t, n) {
                n.element[0] === e[0] && (i = n.event)
            })
        }
    }
}]);
//# sourceMappingURL=ngDraggable.min.js.map